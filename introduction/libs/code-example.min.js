const style = ':host,* { box-sizing: border-box; }\r\n\r\n:host\r\n{\r\n\r\n    grid-template-columns: minmax(100px, 1fr) minmax(100px, 1fr);\r\n\r\n    --gap-small: 3px;\r\n    --gap-medium: 6px;\r\n\r\n    --spinner-track: oklch(25.11% 0.006 258.36 / .2);\r\n    --spinner-thumb: oklch(25.11% 0.006 258.36);\r\n\r\n    --surface-header: oklch(25.11% 0.006 258.36);\r\n    --surface-source: oklch(91.87% 0.003 264.54);\r\n    --surface-html: oklch(74.61% 0.171 51.56);\r\n    --surface-css: oklch(54.87% 0.222 260.33);\r\n    --surface-code: oklch(80.73% 0.002 247.84);\r\n    --surface-js: oklch(89% 0.146 91.5);\r\n    --surface-success: oklch(70.03% 0.194 144.71);\r\n    --surface-error: oklch(54.41% 0.214 19.06);\r\n\r\n    --text-header: oklch(61.01% 0.005 271.34);\r\n    --text-source: oklch(25.11% 0.006 258.36);\r\n    --text-html: oklch(32.49% 0.113 51.98);\r\n    --text-css: oklch(89.66% 0.046 260.67);\r\n    --text-code: oklch(35.02% 0.005 236.66);\r\n    --text-js: oklch(42.29% 0.097 91.9);\r\n\r\n    --badge-size: 26px;\r\n\r\n    color-scheme: light dark;\r\n    display: grid;\r\n    gap: var(--gap-medium);\r\n    margin: var(--gap-medium);\r\n    font-family: var(--font-family, monospace);\r\n}\r\n\r\n#sources\r\n{\r\n    display: grid;\r\n    gap: var(--gap-medium);\r\n    grid-row: 1;\r\n}\r\n\r\n.panel\r\n{\r\n    overflow: hidden;\r\n    counter-reset: line;\r\n    display: grid;\r\n    grid-template-rows: auto 1fr;\r\n    grid-template-columns: 1fr;\r\n    max-height: 300px;\r\n}\r\n\r\n.panel .content\r\n{\r\n    overflow: auto;\r\n    display: grid;\r\n    grid-template-columns: auto 1fr;\r\n    background: #2d2d2d;\r\n}\r\n\r\n#code-source-panel\r\n{\r\n    display: none;\r\n}\r\n:host(.show-code) #code-source-panel\r\n{\r\n    display: grid;\r\n}\r\n#html-source-panel\r\n{\r\n    display: none;\r\n}\r\n:host(.show-html) #html-source-panel\r\n{\r\n    display: grid;\r\n}\r\n#style-source-panel\r\n{\r\n    display: none;\r\n}\r\n:host(.show-style) #style-source-panel\r\n{\r\n    display: grid;\r\n}\r\n\r\n.source-header\r\n{\r\n    grid-column: span 2;\r\n    display: grid;\r\n    grid-template-columns: auto 1fr auto;\r\n    align-items: flex-end;\r\n    font-size: 18px;\r\n    font-weight: bold;\r\n    gap: var(--gap-medium);\r\n    padding: var(--gap-medium);\r\n    background-color: var(--surface-header);\r\n    color: var(--text-header);\r\n    border-top-left-radius: 3px;\r\n    border-top-right-radius: 3px;\r\n}\r\n\r\n.badge\r\n{\r\n    width: var(--badge-size);\r\n    height: var(--badge-size);\r\n    display: inline-flex;\r\n    align-items: flex-end;\r\n    justify-content: flex-end;\r\n    font-size: 9px;\r\n    font-weight: bold;\r\n    padding: 2px;\r\n    border-radius: 2px;\r\n    box-sizing: border-box;\r\n}\r\n\r\n#html-source-badge\r\n{\r\n    background-color: var(--surface-html);\r\n    color: var(--text-html);\r\n    font-size: 7px;\r\n}\r\n#style-source-badge\r\n{\r\n    background-color: var(--surface-css);\r\n    color: var(--text-css);\r\n}\r\n#code-source-badge\r\n{\r\n    background-color: var(--surface-code);\r\n    color: var(--text-code);\r\n}\r\n.language-js #code-source-badge\r\n,.language-javascript #code-source-badge\r\n{\r\n    background-color: var(--surface-js);\r\n    color: var(--text-js);\r\n}\r\n\r\nbutton.copy\r\n{\r\n    display: grid;\r\n    grid-template-columns: 1fr;\r\n    grid-template-rows: 1fr;\r\n    background: none;\r\n    border: none;\r\n    padding: 0;\r\n    margin: 0;\r\n    --icon-primary-color: var(--text-header);\r\n    --icon-secondary-color: var(--surface-header);\r\n}\r\nbutton.copy:hover\r\n{\r\n    --icon-primary-color: var(--surface-source);\r\n}\r\n\r\n.icon\r\n{\r\n    width: var(--copy-button-size, 20px);\r\n    height: var(--copy-button-size, 20px);\r\n    grid-column: 1;\r\n    grid-row: 1;\r\n}\r\n.icon.success\r\n{\r\n    --icon-primary-color: var(--surface-success);\r\n    opacity: 0;\r\n}\r\n.icon.error\r\n{\r\n    --icon-primary-color: var(--surface-error);\r\n    opacity: 0;\r\n}\r\n\r\n.panel.success .icon.success\r\n,.panel.error .icon.error\r\n{\r\n    opacity: 1;\r\n}\r\n.panel:is(.success,.error) .icon.copy\r\n{\r\n    opacity: 0;\r\n}\r\n\r\n\r\n.panel.success .icon.success\r\n{\r\n  animation: bounce-in .75s ease forwards;\r\n}\r\n@keyframes bounce-in {\r\n  0% {\r\n    opacity: 0;\r\n    transform: scale(.3);\r\n  }\r\n  20% {\r\n    opacity: 1;\r\n    transform: scale(1.1);\r\n  }\r\n  30% { transform: scale(.9); }\r\n  100% { transform: scale(1) rotate(1deg); }\r\n}\r\n.panel.error .icon.error {\r\n  animation: shake .35s linear forwards;\r\n}\r\n@keyframes shake {\r\n	0%, 100% { transform: translateX(0); }\r\n	10%, 30% { transform: translateX(-2px); }\r\n	50%, 70% { transform: translateX(-1px); }\r\n	90% { transform: translateX(-.5px); }\r\n	20% { transform: translateX(2px); }\r\n	40%, 60% { transform: translateX(1px); }\r\n	80% { transform: translateX(.5px); }\r\n}\r\n\r\ncode.source\r\n{\r\n    min-height: 27px;\r\n    min-width: 70px;\r\n    \r\n    display: block;\r\n    border-bottom-right-radius: 3px;\r\n    overflow: visible;\r\n\r\n}\r\n\r\n.line-numbers\r\n{\r\n    border-right: solid 1px #222;\r\n    display: grid;\r\n    grid-auto-rows: min-content;\r\n    width: 4ch;\r\n    color: #ccc;\r\n    font-family: monospace;\r\n    font-size: 1em;\r\n    text-align: left;\r\n    word-spacing: normal;\r\n    word-break: normal;\r\n    word-wrap: normal;\r\n    white-space: pre;\r\n    line-height: 1.5;\r\n    padding: 1em 0;\r\n    border-bottom-left-radius: 3px;\r\n    overflow: visible;\r\n    background: #2d2d2d;\r\n    position: sticky;\r\n    left: 0;\r\n}\r\n.line-number\r\n{\r\n    display: flex;\r\n    justify-content: flex-end;\r\n    counter-increment: line;\r\n}\r\n.line-number:before\r\n{\r\n    content: counter(line);\r\n    display: inline-block;\r\n    text-align: right;\r\n    padding-right: 0.5em;\r\n    color: #888;\r\n}\r\n\r\n#preview\r\n{\r\n    border: none;\r\n    width: 100%;\r\n    height: 100%;\r\n    grid-row: 1;\r\n    grid-column: 2;\r\n}\r\n::slotted([slot="preview"])\r\n{\r\n    grid-row: 1;\r\n    grid-column: 2;\r\n}\r\n\r\n#spinner\r\n{\r\n    grid-column: 2;\r\n    grid-row: 1;\r\n\r\n    align-self: center;\r\n    justify-self: center;\r\n\r\n    margin: 60px auto;\r\n    font-size: 10px;\r\n    position: relative;\r\n    text-indent: -9999em;\r\n    border-top: 1.1em solid var(--spinner-track);\r\n    border-right: 1.1em solid var(--spinner-track);\r\n    border-bottom: 1.1em solid var(--spinner-track);\r\n    border-left: 1.1em solid var(--spinner-thumb);\r\n    -webkit-transform: translateZ(0);\r\n    -ms-transform: translateZ(0);\r\n    transform: translateZ(0);\r\n    -webkit-animation: spin 1.1s infinite linear;\r\n    animation: spin 1.1s infinite linear;\r\n\r\n    opacity: 0;\r\n    pointer-events: none;\r\n    z-index: 10;\r\n}\r\n#spinner,\r\n#spinner:after\r\n{\r\n    border-radius: 50%;\r\n    width: var(--spinner-size, 50px);\r\n    height: var(--spinner-size, 50px);\r\n}\r\n\r\n:host(.loading) #spinner\r\n,:host([loading]) #spinner\r\n{\r\n    opacity: 1;\r\n    pointer-events: initial;\r\n}\r\n\r\n:host([theme="vs-dark"])\r\n,:host([theme="hc-black"])\r\n{\r\n    --spinner-track: rgba(255, 255, 255, 0.2);\r\n    --spinner-thumb: #ffffff;\r\n}\r\n\r\n@keyframes spin\r\n{\r\n    from { transform: rotate(0deg); }\r\n    to { transform: rotate(360deg); }\r\n}\r\n\r\n#icon-templates\r\n{\r\n    display: none;\r\n}\r\n\r\n:host(.stack)\r\n{\r\n    grid-template-columns: 1fr;\r\n}\r\n:host(.stack) #sources\r\n,:host(.stack) #preview\r\n,:host(.stack) ::slotted([slot="preview"])\r\n,:host(.stack) #spinner\r\n{\r\n    grid-column: 1;\r\n}\r\n:host(.stack) #spinner\r\n{\r\n    grid-row: 2;\r\n}\r\n:host(.stack) #preview\r\n,:host(.stack) ::slotted([slot="preview"])\r\n{\r\n    grid-row: 2;\r\n    min-height: 300px;\r\n}\r\n\r\n@media (min-width: 665px) \r\n{\r\n    :host(.stack.inline-editors) #sources\r\n    {\r\n        display: flex;\r\n        flex-wrap: wrap;\r\n    }\r\n    :host(.stack.inline-editors) #sources .panel\r\n    {\r\n        flex-basis: 400px;\r\n        flex-grow: 1;\r\n    }\r\n}\r\n@media (max-width: 665px) \r\n{\r\n    :host\r\n    {\r\n        grid-template-columns: 1fr;\r\n    }\r\n    #sources\r\n    ,#preview\r\n    ,::slotted([slot="preview"])\r\n    ,#spinner\r\n    {\r\n        grid-column: 1;\r\n    }\r\n    #spinner\r\n    {\r\n        grid-row: 2;\r\n    }\r\n    #preview\r\n    ,::slotted([slot="preview"])\r\n    {\r\n        grid-row: 2;\r\n        min-height: 300px;\r\n    }\r\n}\r\n\r\n:host([preview="false"])\r\n{\r\n    grid-template-columns: 1fr;\r\n}\r\n:host([preview="false"]) #preview\r\n,:host([preview="false"]) ::slotted([slot="preview"])\r\n,:host([preview="false"]) #spinner\r\n{\r\n    display: none;\r\n}';
const tomorrowNightStyle = "/**\n * prism.js tomorrow night eighties for JavaScript, CoffeeScript, CSS and HTML\n * Based on https://github.com/chriskempson/tomorrow-theme\n * @author Rose Pritchard\n */\ncode {\n	color: #ccc;\n	background: #2d2d2d;\n	font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;\n	font-size: 1em;\n	text-align: left;\n	word-spacing: normal;\n	word-break: normal;\n	word-wrap: normal;\n	white-space: pre;\n	line-height: 1.5;\n	padding: 1em;\n	overflow: auto;\n\n	-moz-tab-size: 4;\n	-o-tab-size: 4;\n	tab-size: 4;\n\n	-webkit-hyphens: none;\n	-moz-hyphens: none;\n	-ms-hyphens: none;\n	hyphens: none;\n\n}\n\n.token.comment,\n.token.block-comment,\n.token.prolog,\n.token.doctype,\n.token.cdata {\n	color: #999;\n}\n\n.token.punctuation {\n	color: #ccc;\n}\n\n.token.tag,\n.token.attr-name,\n.token.namespace,\n.token.deleted {\n	color: #e2777a;\n}\n\n.token.function-name {\n	color: #6196cc;\n}\n\n.token.boolean,\n.token.number,\n.token.function {\n	color: #f08d49;\n}\n\n.token.property,\n.token.class-name,\n.token.constant,\n.token.symbol {\n	color: #f8c555;\n}\n\n.token.selector,\n.token.important,\n.token.atrule,\n.token.keyword,\n.token.builtin {\n	color: #cc99cd;\n}\n\n.token.string,\n.token.char,\n.token.attr-value,\n.token.regex,\n.token.variable {\n	color: #7ec699;\n}\n\n.token.operator,\n.token.entity,\n.token.url {\n	color: #67cdcc;\n}\n\n.token.important,\n.token.bold {\n	font-weight: bold;\n}\n.token.italic {\n	font-style: italic;\n}\n\n.token.entity {\n	cursor: help;\n}\n\n.token.inserted {\n	color: green;\n}\n";
const html = '<div id="sources">\r\n    <div id="code-source-panel" class="panel">\r\n        <header id="code-source-header" class="source-header">\r\n            <slot name="code-badge">\r\n                <span id="code-source-badge" class="badge">&lt;/&gt;</span>\r\n            </slot>\r\n            <slot name="code-title">\r\n                <span id="code-source-title" class="title">Code</span>\r\n            </slot>\r\n            <button class="copy" type="button" title="Copy example code">\r\n                <svg class="icon copy" part="svg icon button-icon copy code">\r\n                    <use href="#icon-definition_copy"></use>\r\n                </svg>\r\n                <svg class="icon error" part="svg icon button-icon error code">\r\n                    <use href="#icon-definition_cancel-cross"></use>\r\n                </svg>\r\n                <svg class="icon success" part="svg icon button-icon success code">\r\n                    <use href="#icon-definition_confirm-check"></use>\r\n                </svg>\r\n            </button>\r\n        </header>\r\n        <div class="content">\r\n            <div class="line-numbers"></div>\r\n            <code id="code-source" class="source line-numbers"></code>\r\n        </div>\r\n    </div>\r\n    <div id="html-source-panel" class="panel">\r\n        <header id="html-source-header" class="source-header">\r\n            <span id="html-source-badge" class="badge">HTML</span>\r\n            <span id="html-source-title" class="title">HTML</span>\r\n            <button class="copy" type="button" title="Copy html code">\r\n                <svg class="icon copy" part="svg icon button-icon copy html">\r\n                    <use href="#icon-definition_copy"></use>\r\n                </svg>\r\n                <svg class="icon error" part="svg icon button-icon error html">\r\n                    <use href="#icon-definition_cancel-cross"></use>\r\n                </svg>\r\n                <svg class="icon success" part="svg icon button-icon success html">\r\n                    <use href="#icon-definition_confirm-check"></use>\r\n                </svg>\r\n            </button>\r\n        </header>\r\n        <div class="content">\r\n            <div class="line-numbers"></div>\r\n            <code id="html-source" class="source"></code>\r\n        </div>\r\n    </div>\r\n    <div id="style-source-panel" class="panel">\r\n        <header id="style-source-header" class="source-header">\r\n            <span id="style-source-badge" class="badge">CSS</span>\r\n            <span id="style-source-title" class="title">CSS</span>\r\n            <button class="copy" type="button" title="Copy style code">\r\n                <svg class="icon copy" part="svg icon button-icon copy style">\r\n                    <use href="#icon-definition_copy"></use>\r\n                </svg>\r\n                <svg class="icon error" part="svg icon button-icon error style">\r\n                    <use href="#icon-definition_cancel-cross"></use>\r\n                </svg>\r\n                <svg class="icon success" part="svg icon button-icon success style">\r\n                    <use href="#icon-definition_confirm-check"></use>\r\n                </svg>\r\n            </button>\r\n        </header>\r\n        <div class="content">\r\n            <div class="line-numbers"></div>\r\n            <code id="style-source" class="source"></code>\r\n        </div>\r\n    </div>\r\n</div>\r\n<slot name="preview">\r\n    <iframe id="preview"></iframe>\r\n</slot>\r\n<div id="spinner"></div>\r\n<template id="preview-template">\r\n    {style}\r\n    {slot}\r\n    {script}\r\n</template>\r\n<div id="icon-templates">\r\n    <svg id="icon-definition_copy" class="icon copy" viewBox="0 0 22.812714 26.814663" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg">\r\n        <rect style="fill:var(--icon-primary-color,CanvasText);stroke:var(--icon-secondary-color,canvas);fill-opacity:1;stroke-width:1;stroke-linecap:round;stroke-linejoin:round;stroke-dasharray:none;stroke-opacity:1;paint-order:normal" width="13.417392" height="18.483608" x="3.3747442" y="5.2238607" rx="0.35822684" ry="0.41754472"></rect>\r\n        <rect style="fill:var(--icon-primary-color,CanvasText);stroke:var(--icon-secondary-color,canvas);fill-opacity:1;stroke-width:1;stroke-linecap:round;stroke-linejoin:round;stroke-dasharray:none;stroke-opacity:1;paint-order:normal" width="13.417392" height="18.483608" x="8.0205779" y="1.1071939" rx="0.35822684" ry="0.41754472"></rect>\r\n    </svg>\r\n    <svg id="icon-definition_cancel-cross" class="icon cancel-cross" viewBox="0 0 22.812714 22.814663" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg">\r\n        <path\r\n        style="color:#000000;fill:var(--icon-primary-color,InfoText);stroke:var(--icon-secondary-color,InfoBackground);stroke-linecap:square;stroke-miterlimit:6.3;stroke-dashoffset:29.2913;stroke-opacity:1;-inkscape-stroke:none"\r\n        d="m 1237.4389,207.63366 -1.8991,1.8987 a 0.65841136,0.65841136 90.003442 0 0 0,0.93116 l 0.4831,0.48317 a 14628.329,14628.329 44.999244 0 0 0.9312,0.93118 l 3.7936,3.79311 a 0.65840885,0.65840885 89.998393 0 1 0,0.93116 l -3.7936,3.7936 a 8783.6896,8783.6896 135.00442 0 1 -0.9313,0.93111 l -0.4829,0.48283 a 0.65811,0.65811 89.993977 0 0 10e-5,0.93094 l 1.8987,1.89741 a 0.65867085,0.65867085 179.98891 0 0 0.9314,-1.8e-4 l 0.4826,-0.48267 a 45427.77,45427.77 134.99941 0 1 0.9312,-0.93119 l 3.7931,-3.79308 a 0.65848899,0.65848899 179.99848 0 1 0.9312,-2e-5 l 3.7936,3.79312 a 10110.91,10110.91 44.992994 0 0 0.9313,0.93108 l 0.483,0.48285 a 0.65856615,0.65856615 179.99438 0 0 0.9313,-9e-5 l 1.897,-1.89705 a 0.65833101,0.65833101 89.994378 0 0 -10e-5,-0.93111 l -0.483,-0.48285 a 5293.5057,5293.5057 44.99639 0 1 -0.9313,-0.93113 l -3.793,-3.79354 a 0.65849247,0.65849247 90.001607 0 1 0,-0.93122 l 3.793,-3.79305 a 149190.44,149190.44 134.99995 0 1 0.9312,-0.93119 l 0.4832,-0.48321 a 0.65863247,0.65863247 90.008202 0 0 10e-5,-0.93132 l -1.8972,-1.89834 a 0.65838576,0.65838576 0.01346964 0 0 -0.9312,-2.2e-4 l -0.483,0.48285 a 7148.543,7148.543 135.00546 0 0 -0.9313,0.9311 l -3.7936,3.79359 a 0.65841791,0.65841791 0.00151591 0 1 -0.9312,-3e-5 l -3.7931,-3.79353 a 52707.551,52707.551 45.002134 0 0 -0.9312,-0.93122 l -0.4826,-0.48267 a 0.65849044,0.65849044 0.00323988 0 0 -0.9312,-5e-5 z"\r\n        transform="translate(-1232.6358,-204.72848)" />\r\n    </svg>\r\n    <svg id="icon-definition_confirm-check" class="icon confirm-check" viewBox="0 0 22.812714 22.814663" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg">\r\n      <path\r\n         style="color:#000000;fill:var(--icon-primary-color,InfoText);stroke:var(--icon-secondary-color,InfoBackground);stroke-linecap:square;stroke-miterlimit:6.3;stroke-dashoffset:29.2913;stroke-opacity:1;-inkscape-stroke:none"\r\n         d="m 1217.8244,205.78897 -0.2601,0.45136 a 1678.5796,1678.5796 119.92232 0 0 -0.7375,1.28138 l -5.9817,10.40385 a 0.56505518,0.56505518 172.50336 0 1 -0.8902,0.11714 l -2.5269,-2.53657 a 11807.915,11807.915 45.113224 0 1 -1.0433,-1.04749 l -0.369,-0.37041 a 0.73898684,0.73898684 0.10741692 0 0 -1.0452,-0.002 l -1.7867,1.78058 a 0.73898921,0.73898921 90.088719 0 0 -0,1.04526 l 0.3681,0.36914 a 1932.0309,1932.0309 45.101339 0 1 1.0436,1.04728 l 6.2204,6.24724 a 0.56490867,0.56490867 172.50982 0 0 0.8901,-0.11702 l 8.5912,-14.94289 a 3197.1389,3197.1389 119.88313 0 0 0.7367,-1.28189 l 0.2597,-0.45232 a 0.7394065,0.7394065 74.876753 0 0 -0.2727,-1.00934 l -2.185,-1.25556 a 0.74005456,0.74005456 164.91559 0 0 -1.0099,0.27222 z"\r\n         transform="translate(-1200.7725,-203.67043)" />\r\n    </svg>\r\n</div>';
const _self = typeof window !== "undefined" ? window : typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope ? self : {};
const environment = _self;
/**
 * Prism: Lightweight, robust, elegant syntax highlighting
 *
 * @license MIT <https://opensource.org/licenses/MIT>
 * @author Lea Verou <https://lea.verou.me>
 * @namespace
 * @public
 */
let Prism$1 = class Prism {
  /**
   * @param {PrismOptions} options
   */
  constructor(options = {}) {
    let plainTextGrammar = {};
    const {
      disableWorkerMessageHandler,
      manual
    } = options;
    this.manual = manual;
    if (this.manual == null) {
      this.manual = true;
    }
    this.plugins = {};
    const _ = this;
    this.disableWorkerMessageHandler = Boolean(disableWorkerMessageHandler);
    this.Token = Token;
    this.util = new Util(this);
    const util = this.util;
    this.languages = {
      /**
       * The grammar for plain, unformatted text.
       */
      plain: plainTextGrammar,
      plaintext: plainTextGrammar,
      text: plainTextGrammar,
      txt: plainTextGrammar,
      /**
       * Creates a deep copy of the language with the given id and appends the given tokens.
       *
       * If a token in `redef` also appears in the copied language, then the existing token in the copied language
       * will be overwritten at its original position.
       *
       * ## Best practices
       *
       * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
       * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
       * understand the language definition because, normally, the order of tokens matters in Prism grammars.
       *
       * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
       * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
       *
       * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
       * @param {Grammar} redef The new tokens to append.
       * @returns {Grammar} The new language created.
       * @public
       * @example
       * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
       *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
       *     // at its original position
       *     'comment': { ... },
       *     // CSS doesn't have a 'color' token, so this token will be appended
       *     'color': /\b(?:red|green|blue)\b/
       * });
       */
      extend: (id, redef) => {
        let lang2 = this.util.clone(this.languages[id]);
        for (var key in redef) {
          lang2[key] = redef[key];
        }
        return lang2;
      },
      /**
       * Inserts tokens _before_ another token in a language definition or any other grammar.
       *
       * ## Usage
       *
       * This helper method makes it easy to modify existing languages. For example, the CSS language definition
       * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
       * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
       * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
       * this:
       *
       * ```js
       * Prism.languages.markup.style = {
       *     // token
       * };
       * ```
       *
       * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
       * before existing tokens. For the CSS example above, you would use it like this:
       *
       * ```js
       * Prism.languages.insertBefore('markup', 'cdata', {
       *     'style': {
       *         // token
       *     }
       * });
       * ```
       *
       * ## Special cases
       *
       * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
       * will be ignored.
       *
       * This behavior can be used to insert tokens after `before`:
       *
       * ```js
       * Prism.languages.insertBefore('markup', 'comment', {
       *     'comment': Prism.languages.markup.comment,
       *     // tokens after 'comment'
       * });
       * ```
       *
       * ## Limitations
       *
       * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
       * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
       * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
       * deleting properties which is necessary to insert at arbitrary positions.
       *
       * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
       * Instead, it will create a new object and replace all references to the target object with the new one. This
       * can be done without temporarily deleting properties, so the iteration order is well-defined.
       *
       * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
       * you hold the target object in a variable, then the value of the variable will not change.
       *
       * ```js
       * var oldMarkup = Prism.languages.markup;
       * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
       *
       * assert(oldMarkup !== Prism.languages.markup);
       * assert(newMarkup === Prism.languages.markup);
       * ```
       *
       * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
       * object to be modified.
       * @param {string} before The key to insert before.
       * @param {Grammar} insert An object containing the key-value pairs to be inserted.
       * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
       * object to be modified.
       *
       * Defaults to `Prism.languages`.
       * @returns {Grammar} The new grammar object.
       * @public
       */
      insertBefore: (inside, before, insert, root) => {
        if (!root) {
          root = /** @type {Record<string, unknown>} */
          this.languages;
        }
        let grammar = root[inside];
        let ret = {};
        for (let token in grammar) {
          if (grammar.hasOwnProperty(token)) {
            if (token == before) {
              for (var newToken in insert) {
                if (insert.hasOwnProperty(newToken)) {
                  ret[newToken] = insert[newToken];
                }
              }
            }
            if (!insert.hasOwnProperty(token)) {
              ret[token] = grammar[token];
            }
          }
        }
        var old = root[inside];
        root[inside] = ret;
        this.languages.DFS(this.languages, function(key, value) {
          if (value === old && key != inside) {
            this[key] = ret;
          }
        });
        return ret;
      },
      // Traverse a language definition with Depth First Search
      DFS(o, callback, type, visited) {
        visited = visited || {};
        var objId = util.objId;
        for (var i in o) {
          if (o.hasOwnProperty(i)) {
            callback.call(o, i, o[i], type || i);
            var property = o[i];
            var propertyType = util.type(property);
            if (propertyType === "Object" && !visited[objId(property)]) {
              visited[objId(property)] = true;
              this.DFS(property, callback, null, visited);
            } else if (propertyType === "Array" && !visited[objId(property)]) {
              visited[objId(property)] = true;
              this.DFS(property, callback, i, visited);
            }
          }
        }
      }
    };
    this.hooks = {
      all: {},
      /**
       * Adds the given callback to the list of callbacks for the given hook.
       *
       * The callback will be invoked when the hook it is registered for is run.
       * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
       *
       * One callback function can be registered to multiple hooks and the same hook multiple times.
       *
       * @param {string} name The name of the hook.
       * @param {HookCallback} callback The callback function which is given environment variables.
       * @public
       */
      add: function(name, callback) {
        var hooks = _.hooks.all;
        hooks[name] = hooks[name] || [];
        hooks[name].push(callback);
      },
      /**
       * Runs a hook invoking all registered callbacks with the given environment variables.
       *
       * Callbacks will be invoked synchronously and in the order in which they were registered.
       *
       * @param {string} name The name of the hook.
       * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
       * @public
       */
      run: function(name, env) {
        var callbacks = _.hooks.all[name];
        if (!callbacks || !callbacks.length) {
          return;
        }
        for (var i = 0, callback; callback = callbacks[i++]; ) {
          callback(env);
        }
      }
    };
    if (!environment.document) {
      if (!environment.addEventListener) {
        return _;
      }
      if (!_.disableWorkerMessageHandler) {
        environment.addEventListener("message", function(evt) {
          var message = JSON.parse(evt.data);
          var lang2 = message.language;
          var code = message.code;
          var immediateClose = message.immediateClose;
          environment.postMessage(_.highlight(code, _.languages[lang2], lang2));
          if (immediateClose) {
            _self.close();
          }
        }, false);
      }
      return _;
    }
    function highlightAutomaticallyCallback() {
      if (!_.manual) {
        _.highlightAll();
      }
    }
    const script = this.util.currentScript();
    if (script) {
      this.filename = script.src;
      if (script.hasAttribute("data-manual")) {
        _.manual = true;
      }
    }
    if (!_.manual) {
      var readyState = document.readyState;
      if (readyState === "loading" || readyState === "interactive" && script && script.defer) {
        document.addEventListener("DOMContentLoaded", highlightAutomaticallyCallback);
      } else {
        if (window.requestAnimationFrame) {
          window.requestAnimationFrame(highlightAutomaticallyCallback);
        } else {
          window.setTimeout(highlightAutomaticallyCallback, 16);
        }
      }
    }
  }
  /**
  * This is the most high-level function in Prism’s API.
  * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
  * each one of them.
  *
  * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
  *
  * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
  * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
  * @memberof Prism
  * @public
  */
  highlightAll(async, callback) {
    this.highlightAllUnder(document, async, callback);
  }
  /**
  	* Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
  	* {@link Prism.highlightElement} on each one of them.
  	*
  	* The following hooks will be run:
  	* 1. `before-highlightall`
  	* 2. `before-all-elements-highlight`
  	* 3. All hooks of {@link Prism.highlightElement} for each element.
  	*
  	* @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
  	* @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
  	* @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
  	* @memberof Prism
  	* @public
  	*/
  highlightAllUnder(container, async, callback) {
    var env = {
      callback,
      container,
      selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
    };
    this.hooks.run("before-highlightall", env);
    env.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));
    this.hooks.run("before-all-elements-highlight", env);
    for (var i = 0, element; element = env.elements[i++]; ) {
      this.highlightElement(element, async === true, env.callback);
    }
  }
  /**
  * Highlights the code inside a single element.
  *
  * The following hooks will be run:
  * 1. `before-sanity-check`
  * 2. `before-highlight`
  * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
  * 4. `before-insert`
  * 5. `after-highlight`
  * 6. `complete`
  *
  * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
  * the element's language.
  *
  * @param {Element} element The element containing the code.
  * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
  * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
  * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
  * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
  *
  * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
  * asynchronous highlighting to work. You can build your own bundle on the
  * [Download page](https://prismjs.com/download.html).
  * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
  * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
  * @public
  */
  highlightElement(element, async, callback) {
    var language = this.util.getLanguage(element);
    var grammar = this.languages[language];
    this.util.setLanguage(element, language);
    var parent = element.parentElement;
    if (parent && parent.nodeName.toLowerCase() === "pre") {
      this.util.setLanguage(parent, language);
    }
    var code = element.textContent;
    var env = {
      element,
      language,
      grammar,
      code
    };
    const insertHighlightedCode = (highlightedCode) => {
      env.highlightedCode = highlightedCode;
      this.hooks.run("before-insert", env);
      env.element.innerHTML = env.highlightedCode;
      this.hooks.run("after-highlight", env);
      this.hooks.run("complete", env);
      callback && callback.call(env.element);
    };
    this.hooks.run("before-sanity-check", env);
    parent = env.element.parentElement;
    if (parent && parent.nodeName.toLowerCase() === "pre" && !parent.hasAttribute("tabindex")) {
      parent.setAttribute("tabindex", "0");
    }
    if (!env.code) {
      this.hooks.run("complete", env);
      callback && callback.call(env.element);
      return;
    }
    this.hooks.run("before-highlight", env);
    if (!env.grammar) {
      insertHighlightedCode(this.util.encode(env.code));
      return;
    }
    if (async && _self.Worker) {
      var worker = new Worker(this.filename);
      worker.onmessage = function(evt) {
        insertHighlightedCode(evt.data);
      };
      worker.postMessage(JSON.stringify({
        language: env.language,
        code: env.code,
        immediateClose: true
      }));
    } else {
      insertHighlightedCode(this.highlight(env.code, env.grammar, env.language));
    }
  }
  /**
  	* Low-level function, only use if you know what you’re doing. It accepts a string of text as input
  	* and the language definitions to use, and returns a string with the HTML produced.
  	*
  	* The following hooks will be run:
  	* 1. `before-tokenize`
  	* 2. `after-tokenize`
  	* 3. `wrap`: On each {@link Token}.
  	*
  	* @param {string} text A string with the code to be highlighted.
  	* @param {Grammar} grammar An object containing the tokens to use.
  	*
  	* Usually a language definition like `Prism.languages.markup`.
  	* @param {string} language The name of the language definition passed to `grammar`.
  	* @returns {string} The highlighted HTML.
  	* @memberof Prism
  	* @public
  	* @example
  	* Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
  	*/
  highlight(text, grammar, language) {
    var env = {
      code: text,
      grammar,
      language
    };
    this.hooks.run("before-tokenize", env);
    if (!env.grammar) {
      throw new Error('The language "' + env.language + '" has no grammar.');
    }
    env.tokens = this.tokenize(env.code, env.grammar);
    this.hooks.run("after-tokenize", env);
    return Token.stringify(this.util.encode(env.tokens), env.language, this);
  }
  /**
  	* This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
  	* and the language definitions to use, and returns an array with the tokenized code.
  	*
  	* When the language definition includes nested tokens, the function is called recursively on each of these tokens.
  	*
  	* This method could be useful in other contexts as well, as a very crude parser.
  	*
  	* @param {string} text A string with the code to be highlighted.
  	* @param {Grammar} grammar An object containing the tokens to use.
  	*
  	* Usually a language definition like `Prism.languages.markup`.
  	* @returns {TokenStream} An array of strings and tokens, a token stream.
  	* @memberof Prism
  	* @public
  	* @example
  	* let code = `var foo = 0;`;
  	* let tokens = Prism.tokenize(code, Prism.languages.javascript);
  	* tokens.forEach(token => {
  	*     if (token instanceof Prism.Token && token.type === 'number') {
  	*         console.log(`Found numeric literal: ${token.content}`);
  	*     }
  	* });
  	*/
  tokenize(text, grammar) {
    var rest = grammar?.rest;
    if (rest) {
      for (var token in rest) {
        grammar[token] = rest[token];
      }
      delete grammar.rest;
    }
    var tokenList = new LinkedList();
    addAfter(tokenList, tokenList.head, text);
    matchGrammar(text, tokenList, grammar, tokenList.head, 0, this);
    return toArray(tokenList);
  }
};
class Token {
  /**
  * @param {string} type See {@link Token#type type}
  * @param {string | TokenStream} content See {@link Token#content content}
  * @param {string|string[]} [alias] The alias(es) of the token.
  * @param {string} [matchedStr=""] A copy of the full string this token was created from.
  	*/
  constructor(type, content, alias, matchedStr) {
    this.type = type;
    this.content = content;
    this.alias = alias;
    this.length = (matchedStr || "").length | 0;
  }
  /**
  * Converts the given token or token stream to an HTML representation.
  *
  * The following hooks will be run:
  * 1. `wrap`: On each {@link Token}.
  *
  * @param {string | Token | TokenStream} o The token or token stream to be converted.
  * @param {string} language The name of current language.
  * @param {Prism} prism - The instance of prism to use for "wrap" hooks
  * @returns {string} The HTML representation of the token or token stream.
  * @memberof Token
  * @static
  */
  static stringify(o, language, prism) {
    const _ = this;
    if (typeof o == "string") {
      return o;
    }
    if (Array.isArray(o)) {
      var s = "";
      o.forEach(function(e) {
        s += _.stringify(
          /** @type {string} */
          e,
          language,
          prism
        );
      });
      return s;
    }
    var env = {
      type: o.type,
      content: _.stringify(o.content, language, prism),
      tag: "span",
      classes: ["token", o.type],
      attributes: {},
      language
    };
    var aliases = o.alias;
    if (aliases) {
      if (Array.isArray(aliases)) {
        Array.prototype.push.apply(env.classes, aliases);
      } else {
        env.classes.push(aliases);
      }
    }
    prism.hooks.run("wrap", env);
    var attributes = "";
    for (var name in env.attributes) {
      attributes += " " + name + '="' + (env.attributes[name] || "").replace(/"/g, "&quot;") + '"';
    }
    return "<" + env.tag + ' class="' + env.classes.join(" ") + '"' + attributes + ">" + env.content + "</" + env.tag + ">";
  }
}
let lang = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i;
let uniqueId = 0;
class Util {
  /**
   * @param {Prism} prism
   */
  constructor(prism) {
    this.prism = prism;
  }
  /**
   * @param {Token | Token[] | string} tokens
   * @return {Token | Token[] | string}
   */
  encode = (tokens) => {
    if (tokens instanceof Token) {
      const content = (
        /** @type {string} */
        tokens.content
      );
      return new Token(
        tokens.type,
        /** @type {string} */
        this.encode(content),
        tokens.alias
      );
    } else if (Array.isArray(tokens)) {
      return tokens.map((token) => (
        /** @type {Token} */
        this.encode(token)
      ));
    } else {
      return tokens.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
    }
  };
  /**
  	* Returns the name of the type of the given value.
  	*
  	* @param {any} o
  	* @returns {string}
  	* @example
  	* type(null)      === 'Null'
  	* type(undefined) === 'Undefined'
  	* type(123)       === 'Number'
  	* type('foo')     === 'String'
  	* type(true)      === 'Boolean'
  	* type([1, 2])    === 'Array'
  	* type({})        === 'Object'
  	* type(String)    === 'Function'
  	* type(/abc+/)    === 'RegExp'
  	*/
  type(o) {
    return Object.prototype.toString.call(o).slice(8, -1);
  }
  /**
  * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
  *
  * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
  *
  * @param {Element} element
  * @returns {string}
  */
  getLanguage(element) {
    while (element) {
      var m = lang.exec(element.className);
      if (m) {
        return m[1].toLowerCase();
      }
      element = element.parentElement;
    }
    return "none";
  }
  /**
  * Sets the Prism `language-xxxx` class of the given element.
  *
  * @param {Element} element
  * @param {string} language
  * @returns {void}
  */
  setLanguage(element, language) {
    element.className = element.className.replace(RegExp(lang, "gi"), "");
    element.classList.add("language-" + language);
  }
  /**
  	* Returns a unique number for the given object. Later calls will still return the same number.
  	*
  	* @param {Object} obj
  	* @returns {number}
  	*/
  objId(obj) {
    if (!obj["__id"]) {
      Object.defineProperty(obj, "__id", { value: ++uniqueId });
    }
    return obj["__id"];
  }
  /**
  * Creates a deep clone of the given object.
  *
  * The main intended use of this function is to clone language definitions.
  *
  * @template T
  * @param {T} o
  * @returns {T}
  */
  clone(o) {
    return structuredClone(o);
  }
  /**
  * Returns whether a given class is active for `element`.
  *
  * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
  * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
  * given class is just the given class with a `no-` prefix.
  *
  * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
  * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
  * ancestors have the given class or the negated version of it, then the default activation will be returned.
  *
  * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
  * version of it, the class is considered active.
  *
  * @param {Element} element
  * @param {string} className
  * @param {boolean} [defaultActivation=false]
  * @returns {boolean}
  */
  isActive(element, className, defaultActivation) {
    var no = "no-" + className;
    while (element) {
      var classList = element.classList;
      if (classList.contains(className)) {
        return true;
      }
      if (classList.contains(no)) {
        return false;
      }
      element = element.parentElement;
    }
    return !!defaultActivation;
  }
  /**
  	* Returns the script element that is currently executing.
  	*
  	* This does __not__ work for line script element.
  	*
  	* @returns {HTMLScriptElement | null}
  	*/
  currentScript() {
    if (typeof document === "undefined") {
      return null;
    }
    if ("currentScript" in document && 1 < 2) {
      return (
        /** @type {any} */
        document.currentScript
      );
    }
    try {
      throw new Error();
    } catch (err) {
      var src = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(err.stack) || [])[1];
      if (src) {
        var scripts = document.getElementsByTagName("script");
        for (var i in scripts) {
          if (scripts[i].src == src) {
            return scripts[i];
          }
        }
      }
      return null;
    }
  }
}
function matchPattern(pattern, pos, text, lookbehind) {
  pattern.lastIndex = pos;
  var match = pattern.exec(text);
  if (match && lookbehind && match[1]) {
    var lookbehindLength = match[1].length;
    match.index += lookbehindLength;
    match[0] = match[0].slice(lookbehindLength);
  }
  return match;
}
function matchGrammar(text, tokenList, grammar, startNode, startPos, prismInstance, rematch) {
  for (var token in grammar) {
    if (!grammar.hasOwnProperty(token) || !grammar[token]) {
      continue;
    }
    var patterns = grammar[token];
    patterns = Array.isArray(patterns) ? patterns : [patterns];
    for (var j = 0; j < patterns.length; ++j) {
      if (rematch && rematch.cause == token + "," + j) {
        return;
      }
      var patternObj = patterns[j];
      var inside = patternObj.inside;
      var lookbehind = !!patternObj.lookbehind;
      var greedy = !!patternObj.greedy;
      var alias = patternObj.alias;
      if (greedy && !patternObj.pattern.global) {
        var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
        patternObj.pattern = RegExp(patternObj.pattern.source, flags + "g");
      }
      var pattern = patternObj.pattern || patternObj;
      for (var currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail; pos += currentNode.value.length, currentNode = currentNode.next) {
        if (rematch && pos >= rematch.reach) {
          break;
        }
        var str = currentNode.value;
        if (tokenList.length > text.length) {
          return;
        }
        if (str instanceof Token) {
          continue;
        }
        var removeCount = 1;
        var match;
        if (greedy) {
          match = matchPattern(pattern, pos, text, lookbehind);
          if (!match || match.index >= text.length) {
            break;
          }
          var from = match.index;
          var to = match.index + match[0].length;
          var p = pos;
          p += currentNode.value.length;
          while (from >= p) {
            currentNode = currentNode.next;
            p += currentNode.value.length;
          }
          p -= currentNode.value.length;
          pos = p;
          if (currentNode.value instanceof Token) {
            continue;
          }
          for (var k = currentNode; k !== tokenList.tail && (p < to || typeof k.value === "string"); k = k.next) {
            removeCount++;
            p += k.value.length;
          }
          removeCount--;
          str = text.slice(pos, p);
          match.index -= pos;
        } else {
          match = matchPattern(pattern, 0, str, lookbehind);
          if (!match) {
            continue;
          }
        }
        var from = match.index;
        var matchStr = match[0];
        var before = str.slice(0, from);
        var after = str.slice(from + matchStr.length);
        var reach = pos + str.length;
        if (rematch && reach > rematch.reach) {
          rematch.reach = reach;
        }
        var removeFrom = currentNode.prev;
        if (before) {
          removeFrom = addAfter(tokenList, removeFrom, before);
          pos += before.length;
        }
        removeRange(tokenList, removeFrom, removeCount);
        var wrapped = new Token(token, inside ? prismInstance.tokenize(matchStr, inside) : matchStr, alias, matchStr);
        currentNode = addAfter(tokenList, removeFrom, wrapped);
        if (after) {
          addAfter(tokenList, currentNode, after);
        }
        if (removeCount > 1) {
          var nestedRematch = {
            cause: token + "," + j,
            reach
          };
          matchGrammar(text, tokenList, grammar, currentNode.prev, pos, prismInstance, nestedRematch);
          if (rematch && nestedRematch.reach > rematch.reach) {
            rematch.reach = nestedRematch.reach;
          }
        }
      }
    }
  }
}
function LinkedList() {
  var head = { value: null, prev: null, next: null };
  var tail = { value: null, prev: head, next: null };
  head.next = tail;
  this.head = head;
  this.tail = tail;
  this.length = 0;
}
function addAfter(list, node, value) {
  var next = node.next;
  var newNode = { value, prev: node, next };
  node.next = newNode;
  next.prev = newNode;
  list.length++;
  return newNode;
}
function removeRange(list, node, count) {
  var next = node.next;
  for (var i = 0; i < count && next !== list.tail; i++) {
    next = next.next;
  }
  node.next = next;
  next.prev = node;
  list.length -= i;
}
function toArray(list) {
  var array = [];
  var node = list.head.next;
  while (node !== list.tail) {
    array.push(node.value);
    node = node.next;
  }
  return array;
}
function loader$3(Prism3, options) {
  if (typeof Prism3 === "undefined") return;
  if (Prism3.languages["markup"]) {
    return;
  }
  Prism3.languages.markup = {
    "comment": {
      pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
      greedy: true
    },
    "prolog": {
      pattern: /<\?[\s\S]+?\?>/,
      greedy: true
    },
    "doctype": {
      // https://www.w3.org/TR/xml/#NT-doctypedecl
      pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
      greedy: true,
      inside: {
        "internal-subset": {
          pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
          lookbehind: true,
          greedy: true,
          inside: null
          // see below
        },
        "string": {
          pattern: /"[^"]*"|'[^']*'/,
          greedy: true
        },
        "punctuation": /^<!|>$|[[\]]/,
        "doctype-tag": /^DOCTYPE/i,
        "name": /[^\s<>'"]+/
      }
    },
    "cdata": {
      pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
      greedy: true
    },
    "tag": {
      pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
      greedy: true,
      inside: {
        "tag": {
          pattern: /^<\/?[^\s>\/]+/,
          inside: {
            "punctuation": /^<\/?/,
            "namespace": /^[^\s>\/:]+:/
          }
        },
        "special-attr": [],
        "attr-value": {
          pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
          inside: {
            "punctuation": [
              {
                pattern: /^=/,
                alias: "attr-equals"
              },
              {
                pattern: /^(\s*)["']|["']$/,
                lookbehind: true
              }
            ]
          }
        },
        "punctuation": /\/?>/,
        "attr-name": {
          pattern: /[^\s>\/]+/,
          inside: {
            "namespace": /^[^\s>\/:]+:/
          }
        }
      }
    },
    "entity": [
      {
        pattern: /&[\da-z]{1,8};/i,
        alias: "named-entity"
      },
      /&#x?[\da-f]{1,8};/i
    ]
  };
  Prism3.languages.markup["tag"].inside["attr-value"].inside["entity"] = Prism3.languages.markup["entity"];
  Prism3.languages.markup["doctype"].inside["internal-subset"].inside = Prism3.languages.markup;
  Prism3.hooks.add("wrap", function(env) {
    if (env.type === "entity") {
      env.attributes["title"] = env.content.replace(/&amp;/, "&");
    }
  });
  Object.defineProperty(Prism3.languages.markup.tag, "addInlined", {
    /**
    	* Adds an inlined language to markup.
    	*
    	* An example of an inlined language is CSS with `<style>` tags.
    	*
    	* @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
    	* case insensitive.
    	* @param {string} lang The language key.
    	* @example
    	* addInlined('style', 'css');
    	*/
    value: function addInlined(tagName, lang2) {
      var includedCdataInside = {};
      includedCdataInside["language-" + lang2] = {
        pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
        lookbehind: true,
        inside: Prism3.languages[lang2]
      };
      includedCdataInside["cdata"] = /^<!\[CDATA\[|\]\]>$/i;
      var inside = {
        "included-cdata": {
          pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
          inside: includedCdataInside
        }
      };
      inside["language-" + lang2] = {
        pattern: /[\s\S]+/,
        inside: Prism3.languages[lang2]
      };
      var def = {};
      def[tagName] = {
        pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
          return tagName;
        }), "i"),
        lookbehind: true,
        greedy: true,
        inside
      };
      Prism3.languages.insertBefore("markup", "cdata", def);
    }
  });
  Object.defineProperty(Prism3.languages.markup.tag, "addAttribute", {
    /**
    	* Adds an pattern to highlight languages embedded in HTML attributes.
    	*
    	* An example of an inlined language is CSS with `style` attributes.
    	*
    	* @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
    	* case insensitive.
    	* @param {string} lang The language key.
    	* @example
    	* addAttribute('style', 'css');
    	*/
    value: function(attrName, lang2) {
      Prism3.languages.markup.tag.inside["special-attr"].push({
        pattern: RegExp(
          /(^|["'\s])/.source + "(?:" + attrName + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
          "i"
        ),
        lookbehind: true,
        inside: {
          "attr-name": /^[^\s=]+/,
          "attr-value": {
            pattern: /=[\s\S]+/,
            inside: {
              "value": {
                pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                lookbehind: true,
                alias: [lang2, "language-" + lang2],
                inside: Prism3.languages[lang2]
              },
              "punctuation": [
                {
                  pattern: /^=/,
                  alias: "attr-equals"
                },
                /"|'/
              ]
            }
          }
        }
      });
    }
  });
  Prism3.languages.html = Prism3.languages.markup;
  Prism3.languages.mathml = Prism3.languages.markup;
  Prism3.languages.svg = Prism3.languages.markup;
  Prism3.languages.xml = Prism3.languages.extend("markup", {});
  Prism3.languages.ssml = Prism3.languages.xml;
  Prism3.languages.atom = Prism3.languages.xml;
  Prism3.languages.rss = Prism3.languages.xml;
}
function loader$2(Prism3, options) {
  if (typeof Prism3 === "undefined") return;
  if (Prism3.languages["css"]) {
    return;
  }
  loader$3(Prism3);
  var string = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
  Prism3.languages.css = {
    "comment": /\/\*[\s\S]*?\*\//,
    "atrule": {
      pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + string.source + ")*?" + /(?:;|(?=\s*\{))/.source),
      inside: {
        "rule": /^@[\w-]+/,
        "selector-function-argument": {
          pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
          lookbehind: true,
          alias: "selector"
        },
        "keyword": {
          pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
          lookbehind: true
        }
        // See rest below
      }
    },
    "url": {
      // https://drafts.csswg.org/css-values-3/#urls
      pattern: RegExp("\\burl\\((?:" + string.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
      greedy: true,
      inside: {
        "function": /^url/i,
        "punctuation": /^\(|\)$/,
        "string": {
          pattern: RegExp("^" + string.source + "$"),
          alias: "url"
        }
      }
    },
    "selector": {
      pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + string.source + ")*(?=\\s*\\{)"),
      lookbehind: true
    },
    "string": {
      pattern: string,
      greedy: true
    },
    "property": {
      pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
      lookbehind: true
    },
    "important": /!important\b/i,
    "function": {
      pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
      lookbehind: true
    },
    "punctuation": /[(){};:,]/
  };
  Prism3.languages.css["atrule"].inside.rest = Prism3.languages.css;
  var markup = Prism3.languages.markup;
  if (markup) {
    markup.tag.addInlined("style", "css");
    markup.tag.addAttribute("style", "css");
  }
}
function loader$1(Prism3, options) {
  if (typeof Prism3 === "undefined") return;
  if (Prism3.languages["clike"]) {
    return;
  }
  Prism3.languages.clike = {
    "comment": [
      {
        pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
        lookbehind: true,
        greedy: true
      },
      {
        pattern: /(^|[^\\:])\/\/.*/,
        lookbehind: true,
        greedy: true
      }
    ],
    "string": {
      pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
      greedy: true
    },
    "class-name": {
      pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
      lookbehind: true,
      inside: {
        "punctuation": /[.\\]/
      }
    },
    "keyword": /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
    "boolean": /\b(?:false|true)\b/,
    "function": /\b\w+(?=\()/,
    "number": /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
    "operator": /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
    "punctuation": /[{}[\];(),.:]/
  };
}
function loader(Prism3, options) {
  if (typeof Prism3 === "undefined") return;
  if (Prism3.languages["javascript"]) {
    return;
  }
  loader$1(Prism3);
  loader$3(Prism3);
  Prism3.languages.javascript = Prism3.languages.extend("clike", {
    "class-name": [
      Prism3.languages.clike["class-name"],
      {
        pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
        lookbehind: true
      }
    ],
    "keyword": [
      {
        pattern: /((?:^|\})\s*)catch\b/,
        lookbehind: true
      },
      {
        pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
        lookbehind: true
      }
    ],
    // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
    "function": /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
    "number": {
      pattern: RegExp(
        /(^|[^\w$])/.source + "(?:" + // constant
        (/NaN|Infinity/.source + "|" + // binary integer
        /0[bB][01]+(?:_[01]+)*n?/.source + "|" + // octal integer
        /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + // hexadecimal integer
        /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + // decimal bigint
        /\d+(?:_\d+)*n/.source + "|" + // decimal number (integer or float) but no bigint
        /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source
      ),
      lookbehind: true
    },
    "operator": /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
  });
  Prism3.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;
  Prism3.languages.insertBefore("javascript", "keyword", {
    "regex": {
      pattern: RegExp(
        // lookbehind
        // eslint-disable-next-line regexp/no-dupe-characters-character-class
        /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + // Regex pattern:
        // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
        // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
        // with the only syntax, so we have to define 2 different regex patterns.
        /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + // `v` flag syntax. This supports 3 levels of nested character classes.
        /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + // lookahead
        /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
      ),
      lookbehind: true,
      greedy: true,
      inside: {
        "regex-source": {
          pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
          lookbehind: true,
          alias: "language-regex",
          inside: Prism3.languages.regex
        },
        "regex-delimiter": /^\/|\/$/,
        "regex-flags": /^[a-z]+$/
      }
    },
    // This must be declared before keyword because we use "function" inside the look-forward
    "function-variable": {
      pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
      alias: "function"
    },
    "parameter": [
      {
        pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
        lookbehind: true,
        inside: Prism3.languages.javascript
      },
      {
        pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
        lookbehind: true,
        inside: Prism3.languages.javascript
      },
      {
        pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
        lookbehind: true,
        inside: Prism3.languages.javascript
      },
      {
        pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
        lookbehind: true,
        inside: Prism3.languages.javascript
      }
    ],
    "constant": /\b[A-Z](?:[A-Z_]|\dx?)*\b/
  });
  Prism3.languages.insertBefore("javascript", "string", {
    "hashbang": {
      pattern: /^#!.*/,
      greedy: true,
      alias: "comment"
    },
    "template-string": {
      pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
      greedy: true,
      inside: {
        "template-punctuation": {
          pattern: /^`|`$/,
          alias: "string"
        },
        "interpolation": {
          pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
          lookbehind: true,
          inside: {
            "interpolation-punctuation": {
              pattern: /^\$\{|\}$/,
              alias: "punctuation"
            },
            rest: Prism3.languages.javascript
          }
        },
        "string": /[\s\S]+/
      }
    },
    "string-property": {
      pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
      lookbehind: true,
      greedy: true,
      alias: "property"
    }
  });
  Prism3.languages.insertBefore("javascript", "operator", {
    "literal-property": {
      pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
      lookbehind: true,
      alias: "property"
    }
  });
  if (Prism3.languages.markup) {
    Prism3.languages.markup.tag.addInlined("script", "javascript");
    Prism3.languages.markup.tag.addAttribute(
      /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
      "javascript"
    );
  }
  Prism3.languages.js = Prism3.languages.javascript;
}
function Plugin(Prism3) {
  if (typeof Prism3 === "undefined" || typeof document === "undefined") {
    return;
  }
  if (!Element.prototype.matches) {
    Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
  }
  var LOADING_MESSAGE = "Loading…";
  var FAILURE_MESSAGE = function(status, message) {
    return "✖ Error " + status + " while fetching file: " + message;
  };
  var FAILURE_EMPTY_MESSAGE = "✖ Error: File does not exist or is empty";
  var EXTENSIONS = {
    "js": "javascript",
    "py": "python",
    "rb": "ruby",
    "ps1": "powershell",
    "psm1": "powershell",
    "sh": "bash",
    "bat": "batch",
    "h": "c",
    "tex": "latex"
  };
  var STATUS_ATTR = "data-src-status";
  var STATUS_LOADING = "loading";
  var STATUS_LOADED = "loaded";
  var STATUS_FAILED = "failed";
  var SELECTOR = "pre[data-src]:not([" + STATUS_ATTR + '="' + STATUS_LOADED + '"]):not([' + STATUS_ATTR + '="' + STATUS_LOADING + '"])';
  function loadFile(src, success, error) {
    var xhr = new XMLHttpRequest();
    xhr.open("GET", src, true);
    xhr.onreadystatechange = function() {
      if (xhr.readyState == 4) {
        if (xhr.status < 400 && xhr.responseText) {
          success(xhr.responseText);
        } else {
          if (xhr.status >= 400) {
            error(FAILURE_MESSAGE(xhr.status, xhr.statusText));
          } else {
            error(FAILURE_EMPTY_MESSAGE);
          }
        }
      }
    };
    xhr.send(null);
  }
  function parseRange(range) {
    var m = /^\s*(\d+)\s*(?:(,)\s*(?:(\d+)\s*)?)?$/.exec(range || "");
    if (m) {
      var start = Number(m[1]);
      var comma = m[2];
      var end = m[3];
      if (!comma) {
        return [start, start];
      }
      if (!end) {
        return [start, void 0];
      }
      return [start, Number(end)];
    }
    return void 0;
  }
  Prism3.hooks.add("before-highlightall", function(env) {
    env.selector += ", " + SELECTOR;
  });
  Prism3.hooks.add("before-sanity-check", function(env) {
    var pre = (
      /** @type {HTMLPreElement} */
      env.element
    );
    if (pre.matches(SELECTOR)) {
      env.code = "";
      pre.setAttribute(STATUS_ATTR, STATUS_LOADING);
      var code = pre.appendChild(document.createElement("CODE"));
      code.textContent = LOADING_MESSAGE;
      var src = pre.getAttribute("data-src");
      var language = env.language;
      if (language === "none") {
        var extension = (/\.(\w+)$/.exec(src) || [, "none"])[1];
        language = EXTENSIONS[extension] || extension;
      }
      Prism3.util.setLanguage(code, language);
      Prism3.util.setLanguage(pre, language);
      var autoloader = Prism3.plugins.autoloader;
      if (autoloader) {
        autoloader.loadLanguages(language);
      }
      loadFile(
        src,
        function(text) {
          pre.setAttribute(STATUS_ATTR, STATUS_LOADED);
          var range = parseRange(pre.getAttribute("data-range"));
          if (range) {
            var lines = text.split(/\r\n?|\n/g);
            var start = range[0];
            var end = range[1] == null ? lines.length : range[1];
            if (start < 0) {
              start += lines.length;
            }
            start = Math.max(0, Math.min(start - 1, lines.length));
            if (end < 0) {
              end += lines.length;
            }
            end = Math.max(0, Math.min(end, lines.length));
            text = lines.slice(start, end).join("\n");
            if (!pre.hasAttribute("data-start")) {
              pre.setAttribute("data-start", String(start + 1));
            }
          }
          code.textContent = text;
          Prism3.highlightElement(code);
        },
        function(error) {
          pre.setAttribute(STATUS_ATTR, STATUS_FAILED);
          code.textContent = error;
        }
      );
    }
  });
  Prism3.plugins.fileHighlight = {
    /**
     * Executes the File Highlight plugin for all matching `pre` elements under the given container.
     *
     * Note: Elements which are already loaded or currently loading will not be touched by this method.
     *
     * @param {ParentNode} [container=document]
     */
    highlight: function highlight(container) {
      var elements = (container || document).querySelectorAll(SELECTOR);
      for (var i = 0, element; element = elements[i++]; ) {
        Prism3.highlightElement(element);
      }
    }
  };
  var logged = false;
  Prism3.fileHighlight = function() {
    if (!logged) {
      console.warn("Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead.");
      logged = true;
    }
    Prism3.plugins.fileHighlight.highlight.apply(this, arguments);
  };
}
class Prism2 extends Prism$1 {
  /**
   * @param {ConstructorParameters<typeof OGPrism>} args
   */
  constructor(...args) {
    super(...args);
    loader$3(this);
    loader$2(this);
    loader$1(this);
    loader(this);
    Plugin(this);
  }
}
const DEFAULT_ELEMENT_SELECTOR = ":not(slot,defs,g,rect,path,circle,ellipse,line,polygon,text,tspan,use,svg image,svg title,desc,template,template *)";
function assignClassAndIdToPart(shadowRoot) {
  assignIdToPart(shadowRoot);
  assignClassToPart(shadowRoot);
}
function assignIdToPart(shadowRoot) {
  const identifiedElements = [...shadowRoot.querySelectorAll(`${DEFAULT_ELEMENT_SELECTOR}[id]`)];
  for (let i = 0; i < identifiedElements.length; i++) {
    identifiedElements[i].part.add(identifiedElements[i].id);
  }
}
function assignClassToPart(shadowRoot) {
  const classedElements = [...shadowRoot.querySelectorAll(`${DEFAULT_ELEMENT_SELECTOR}[class]`)];
  for (let i = 0; i < classedElements.length; i++) {
    classedElements[i].part.add(...classedElements[i].classList);
  }
}
const CodeExampleSlotKeys = {
  slot: "slot",
  html: "html",
  script: "script",
  javascript: "javascript",
  js: "js",
  code: "code",
  style: "style",
  css: "css"
};
const COMPONENT_STYLESHEET = new CSSStyleSheet();
COMPONENT_STYLESHEET.replaceSync(`
${tomorrowNightStyle}
${style}`);
const COMPONENT_TAG_NAME = "code-example";
class CodeExampleElement extends HTMLElement {
  findElement(id) {
    return this.shadowRoot.getElementById(id);
  }
  prism;
  #previewTemplateContent = "";
  constructor() {
    super();
    this.attachShadow({ mode: "open" });
    this.shadowRoot.innerHTML = html;
    this.shadowRoot.adoptedStyleSheets.push(COMPONENT_STYLESHEET);
    this.prism = new Prism2({ manual: true });
  }
  #injectIntoPreview(style2, html2, code) {
    const allowProcess = this.dispatchEvent(new CustomEvent("preview", { detail: { code, html: html2, style: style2 }, cancelable: true, bubbles: true, composed: true }));
    const slottedPreview = this.querySelector(':scope > [slot="preview"]');
    if (allowProcess == false || slottedPreview != null) {
      return;
    }
    const previewFrame = this.findElement("preview");
    const previewDocument = previewFrame.contentDocument || previewFrame.contentWindow?.document;
    if (previewDocument == null) {
      throw new Error("Preview iframe's document is null.");
    }
    const htmlTarget = this.#previewTemplateContent.match(/{html}/);
    const codeTarget = this.#previewTemplateContent.match(/{js}|{javascript}|{script}/);
    const styleTarget = this.#previewTemplateContent.match(/{css}|{style}/);
    const sortedContent = {
      [CodeExampleSlotKeys.slot]: [],
      [CodeExampleSlotKeys.html]: [],
      [CodeExampleSlotKeys.style]: [],
      [CodeExampleSlotKeys.code]: []
    };
    if (htmlTarget?.[0] == `{${CodeExampleSlotKeys.html}}`) {
      sortedContent[CodeExampleSlotKeys.html].push(html2);
    } else {
      sortedContent[CodeExampleSlotKeys.slot].push(html2);
    }
    const codeSlotText = codeTarget?.[0];
    if (codeSlotText == `{${CodeExampleSlotKeys.javascript}}` || codeSlotText == `{${CodeExampleSlotKeys.js}}` || codeSlotText == `{${CodeExampleSlotKeys.code}}` || codeSlotText == `{${CodeExampleSlotKeys.script}}`) {
      sortedContent[CodeExampleSlotKeys.code].push(code);
    } else {
      sortedContent[CodeExampleSlotKeys.slot].push(`<script${this.hasAttribute("script-module") ? ' type="module"' : ""}>${code}<\/script>`);
    }
    const styleSlotText = styleTarget?.[0];
    if (styleSlotText == `{${CodeExampleSlotKeys.css}}` || styleSlotText == `{${CodeExampleSlotKeys.style}}`) {
      sortedContent[CodeExampleSlotKeys.style].push(style2);
    } else {
      sortedContent[CodeExampleSlotKeys.slot].push(style2);
    }
    const previewDocumentContent = `<!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>Example Preview Frame</title>
            <style>
                html, body { color-scheme: light dark; font-size: 16px; }
                ${sortedContent[CodeExampleSlotKeys.style].join("/n")}
            </style>
        </head>
        <body part="preview-body">
            ${sortedContent[CodeExampleSlotKeys.slot].join("/n")}
            <script${this.hasAttribute("script-module") ? ' type="module"' : ""}>${sortedContent[CodeExampleSlotKeys.code].join("/n")}<\/script>
        </body>
        </html>`;
    previewDocument.open();
    previewDocument.write(previewDocumentContent);
    previewDocument.close();
    const dependencies = this.getAttribute("preview-script");
    if (dependencies != null) {
      const moduleAttribute = this.getAttribute("preview-script-module");
      const paths = dependencies.split(",");
      const modules = moduleAttribute?.split(",") ?? [];
      for (let i = 0; i < paths.length; i++) {
        try {
          const script = previewDocument.createElement("script");
          if (moduleAttribute == null || modules[i] == void 0 || modules[i] == "false") {
            script.src = paths[i];
            previewDocument.head.appendChild(script);
            continue;
          }
          script.setAttribute("type", "module");
          script.src = paths[i];
          previewDocument.head.appendChild(script);
        } catch (exception) {
          console.error(`Error loading preview dependency script: ${exception.message}`);
        }
      }
    }
  }
  #loadSourceContent() {
    this.classList.toggle("loading", true);
    const htmlSource = this.findElement("html-source");
    const styleSource = this.findElement("style-source");
    const codeSource = this.findElement("code-source");
    const codeElements = [...this.querySelectorAll(":scope > code[slot]")];
    for (let i = 0; i < codeElements.length; i++) {
      const codeElement = codeElements[i];
      this.#refreshSourceHighlight(codeElement, htmlSource, styleSource, codeSource);
    }
    if (this.getAttribute("preview") != "false") {
      this.#injectIntoPreview(styleSource.textContent, htmlSource.textContent, codeSource.textContent);
    }
    this.classList.toggle("loading", false);
  }
  #refreshSourceHighlight(codeElement, htmlSource, styleSource, codeSource) {
    const languageClass = [...codeElement.classList].find((item) => item.startsWith("language-"));
    const language = languageClass != null ? languageClass.substring(9) : "";
    const sourceElement = language == "html" ? htmlSource ?? this.findElement("html-source") : language == "style" || language == "css" ? styleSource ?? this.findElement("style-source") : codeSource ?? this.findElement("code-source");
    sourceElement.setAttribute("class", "");
    if (languageClass != null) {
      sourceElement.classList.add("source", languageClass);
      sourceElement.parentElement.parentElement.classList.add(languageClass);
    }
    if (language == "js" || language == "javascript") {
      sourceElement.parentElement.parentElement.querySelector("header .badge").textContent = "JS";
      sourceElement.parentElement.parentElement.querySelector("header .title").textContent = "JS";
    }
    if (language == "css" || language == "style") {
      this.classList.add("show-style");
    } else if (language == "html") {
      this.classList.add("show-html");
    } else {
      this.classList.add("show-code");
    }
    let code = language == "html" ? codeElement.innerHTML : codeElement.textContent;
    const lines = code.split("\n");
    const whitespaceToTrim = this.#getFirstLineLeadingWhitespace(lines);
    code = code.replaceAll(new RegExp(`^[ 	]{0,${whitespaceToTrim}}`, "gm"), "");
    code = code.trim();
    this.#createLineNumbers(sourceElement.parentElement, lines);
    if (this.prism.languages[language] != null) {
      const result = this.prism.highlight(code, this.prism.languages[language], language);
      code = result;
    }
    sourceElement.innerHTML = code;
  }
  #getFirstLineLeadingWhitespace(lines) {
    const firstLine = lines[1] ?? lines[0];
    if (firstLine == null) {
      return 0;
    }
    const trimmedLine = firstLine.trimStart();
    const leadingSpaces = firstLine.length - trimmedLine.length;
    return leadingSpaces;
  }
  #createLineNumbers(sourceElement, lines) {
    const linesContent = [];
    for (let i = 0; i < lines.length - 2; i++) {
      linesContent.push('<div class="line-number" part="line-number"></div>');
    }
    if (linesContent.length < 1 && lines.length > 0) {
      linesContent.push('<div class="line-number" part="line-number"></div>');
    }
    const lineNumbers = sourceElement.querySelector(".line-numbers");
    lineNumbers.innerHTML = linesContent.join("\n");
  }
  appendScriptElementToHTMLExample(sourcePath, type) {
    const code = this.querySelector("code.language-html");
    if (code == null) {
      console.error("Unable to inject script into code: No code node found.");
      return;
    }
    const index = code.childNodes.length - 1;
    this.injectScriptElementToHTMLExample(sourcePath, type, index);
  }
  prependScriptElementToHTMLExample(sourcePath, type) {
    this.injectScriptElementToHTMLExample(sourcePath, type, 0);
  }
  injectScriptElementToHTMLExample(sourcePath, type, childNodeIndex = 0) {
    const code = this.querySelector("code.language-html");
    if (code == null) {
      console.error("Unable to inject script into code: No code node found.");
      return;
    }
    const scriptElement = document.createElement("script");
    if (type != null) {
      scriptElement.type = type;
    }
    scriptElement.src = sourcePath;
    code.insertBefore(scriptElement, code.childNodes[childNodeIndex]);
    code.insertBefore(document.createTextNode("\n"), code.childNodes[childNodeIndex + 1]);
    this.replaceSource(code.innerHTML);
  }
  replaceSource(newCode) {
    const sourceElements = [...this.querySelectorAll(":scope > code[slot]")];
    const codeElement = sourceElements.find((item) => item.classList.contains("language-html") || item.classList.contains("language-css") || item.classList.contains("language-style"));
    let target = codeElement;
    if (target != null) {
      if (target.classList.contains("language-html") == true) {
        target.innerHTML = newCode;
      } else {
        target.textContent = newCode;
      }
    } else if (sourceElements[0] != null) {
      target = sourceElements[0];
      target.textContent = newCode;
    }
    if (target != null) {
      this.#refreshSourceHighlight(target);
    }
  }
  loadLanguage(loader2) {
    loader2(this.prism);
    const sourceElements = [...this.querySelectorAll(":scope > code[slot]")];
    const codeElement = sourceElements.find((item) => !item.classList.contains("language-html") && !item.classList.contains("language-css") && !item.classList.contains("language-style"));
    if (codeElement != null) {
      this.#refreshSourceHighlight(codeElement);
    }
  }
  #boundScrollHandler = ((event) => {
    const code = event.target;
    const lineNumbers = code.parentElement.querySelector(".line-numbers");
    if (code.scrollTop + code.offsetHeight > lineNumbers.scrollHeight) {
      code.scrollTop = lineNumbers.scrollTop;
    } else {
      lineNumbers.scrollTop = code.scrollTop;
    }
  }).bind(this);
  connectedCallback() {
    const previewTemplate = this.querySelector("template") ?? this.findElement("preview-template");
    if (previewTemplate.textContent.indexOf("{slot}") == null) {
      throw new Error(`Cannot use a preview template that does not contain a slot named "slot".`);
    }
    this.#previewTemplateContent = previewTemplate.innerHTML;
    this.#loadSourceContent();
    assignClassAndIdToPart(this.shadowRoot);
    this.addEventListener("click", this.#boundClickHandler);
  }
  disconnectedCallback() {
    this.removeEventListener("click", this.#boundClickHandler);
    const panels = [...this.shadowRoot.querySelectorAll(".panel")];
    for (let i = 0; i < panels.length; i++) {
      const code = panels[i].querySelector("code");
      code.removeEventListener("scroll", this.#boundScrollHandler);
    }
  }
  #boundClickHandler = this.#onClick.bind(this);
  async #onClick(event) {
    const composedPath = event.composedPath();
    const copyButton = composedPath.find((item) => item instanceof HTMLButtonElement && item.classList.contains("copy"));
    if (copyButton != null) {
      const panel = copyButton.closest(".panel");
      if (panel == null) {
        return;
      }
      const source = panel.querySelector("code").textContent;
      try {
        await navigator.clipboard.writeText(source);
        panel.classList.add("success");
        panel.part.add("success");
      } catch (err) {
        panel.classList.add("error");
        panel.part.add("error");
        console.error("Failed to copy text:", err);
      }
      setTimeout(() => {
        panel.classList.remove("success", "error");
        panel.part.remove("success", "error");
      }, 1e3);
    }
  }
}
if (customElements.get(COMPONENT_TAG_NAME) == null) {
  customElements.define(COMPONENT_TAG_NAME, CodeExampleElement);
}
export {
  CodeExampleElement,
  CodeExampleSlotKeys
};
